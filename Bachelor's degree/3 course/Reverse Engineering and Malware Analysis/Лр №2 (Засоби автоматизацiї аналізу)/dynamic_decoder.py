from pwn import *

from unicorn import *
from unicorn.x86_const import *

from capstone import *
cs = Cs(CS_ARCH_X86, CS_MODE_64)

base = 0x0
size_code = 1024*1024
stack_adress = 0x100000
size_stack = 1024*1024


def hook_code(uc, address, size, user_data):
    print('hook_code: {} '.format(mu.mem_read(0x10, 42)))
    ins = uc.mem_read(address, size)  # Виконуємо зчитування команд
    for com in cs.disasm(ins, 0):
        if com.mnemonic == "je":  # Якщо не існує нуступної команди дизасемблерного лістингу, то зупиняємо зчитування
            uc.emu_stop()
        else:
            print("hook 0x{:03x} size:{}   {} {}".format(address, size, com.mnemonic, com.op_str))


mu = Uc(UC_ARCH_X86, UC_MODE_64)                 # Initializing Unicorn engine class for architecture x86, 64 bit.

mu.mem_map(base, size_code)                      # Mapping memory for the code.
mu.mem_map(stack_adress, size_stack)             # Mapping memory for a stack.
mu.mem_write(base, read('./payload.bin'))        # Load the binary at our base address.
mu.reg_write(UC_X86_REG_RSP, stack_adress + size_stack - 1) # Set RSP to point at the end of the stack.
mu.hook_add(UC_HOOK_CODE, hook_code)             # hook_code() function is called before emulation of each instruction.


mu.emu_start(0x0, 0xd)

